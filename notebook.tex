
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{sorting\_algorithms}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{An Investigation of Sorting
Algorithms}\label{an-investigation-of-sorting-algorithms}

    \subsection{Libraries}\label{libraries}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np} \PY{c+c1}{\PYZsh{} For randomly generating numbers}
         \PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k}{as} \PY{n+nn}{pd} \PY{c+c1}{\PYZsh{}For reading csv files, generating dataframes and plots for same}
         \PY{k+kn}{import} \PY{n+nn}{time}
\end{Verbatim}


    \subsection{Introduction}\label{introduction}

    A sorting algorithm arranges a list of items in some predetermined
order.

When dealing with strings, this may involve sorting elements in
alphabethical order. For this investigation, I'm going to look at
ordering discrete numerical elements, in ascending order, for smallest
to biggest. Sorting is essentially a permutation of list elements, and
does not alter any of the elements in the list.

Much of early computing advancements focused on finding effective
sorting methods. This is because sorting elements allow for a number of
tasks to be completed quicker than in a list of unsorted items. It's
essential in data analysis, when determining the maximum, minimum,
median and inter-quartile range. Also, sorting is often pre-processing
step in search algorithms, allowing for more effective identification of
specific or duplicate entries.

    \textbf{Terminology}

\begin{itemize}
\item
  The \textbf{worst - case scenario} refers to an input that will result
  in the longest possible running time. In the case of sorting
  algorithms, this will often refer to an input that is in reverse
  order.
\item
  With respect to duplicate entries, a \textbf{stable sorting algorithm}
  will preserve the order of duplicate entries while an \textbf{unstable
  sorting algorithm} will not. All of the sorting algorithms I've chosen
  to investigate are stable sorting algorithms.
\item
  An \textbf{in-place sorting algorithm} uses a fixed additional amount
  of working space, and is independent of it's input size. Another
  definition of an in-place algorithm states that the input is usually
  overwritten by the output.
\end{itemize}

    ** Project Intentions **

In the course of this investigation, I will discuss and benchmark the
following sorting algorithms: * Bubble Sort * Binary Insertion Sort *
Merge Sort * Bucket Sort * Tim Sort

I have chosen these sorting algorithms as they include examples of
simple and effective comparison based sorting algorithms, non-comparison
based sorting algorithms and hybrid sorting algorithms. My decision to
examine Binary Insertion Sort, was in part due to the improved time
complexity of this algorithm, when compared to the traditional Insertion
Sort. It also made sense to examine this variation of Insertion Sort, as
it is necessary to run TimSort.

I will discuss these types of sortings algorithms with reference to the
specific examples I have chosen, and plot their running time against the
size of inputs. To more effectively compare these algorithms, I will
also run each algorithm ten times for each input, and determine the
average running time.

    \textbf{Considerations:}

\textbf{Time Complexity and Big O Notation}

When benchmarking algorithms, we are often concerned with how long it
takes a function to execute. This is a complex question to answer and
the answer varies considerabily based on the input size, and the
specification of the machine running the program.

Time Complexity is a way we can measure how the execution time increases
as the input sizes increases. It can be most simplistically described as
a function which models the execution time, given incrementally
increasing input sizes. However in most instances, inputs with the same
size can have different execution times.

As a result we may need to consider the worst case, best case and
average case complexities to fully understand the limitations of an
algorithm.

Big O notation is a mathematical notation used to classify algorithms
based on their worst case time complexity. * \(O(n)\) describes an
algorithm whose time complexity increases linearly and is proportionate
to its input size. * \(O(n^2)\) describes an algorithm whose time
complexity is best modelled by a quadratic function. It is common in
algorithms featuring nested iterations through a dataset. *
\(O(log {}n)\)

    \textbf{Space Complexity}

    \subsection{Functions}\label{functions}

\subsubsection{Generating Random Data}\label{generating-random-data}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}92}]:} \PY{c+c1}{\PYZsh{}Function used to generate random data}
         \PY{k}{def} \PY{n+nf}{rand}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
             \PY{n}{array} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{n}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{} for every integer between 1 and n}
                 \PY{n}{gen\PYZus{}rand}\PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{)} \PY{c+c1}{\PYZsh{} generate a random number}
                 \PY{n}{array}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{gen\PYZus{}rand}\PY{p}{)} \PY{c+c1}{\PYZsh{} and add it to the array}
             \PY{k}{return} \PY{n}{array}
\end{Verbatim}


    \subsubsection{Benchmarking Functions}\label{benchmarking-functions}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}124}]:} \PY{c+c1}{\PYZsh{}Inputs each random array to each function ONLY ONCE}
          \PY{c+c1}{\PYZsh{}Returns running time in milliseconds}
          \PY{k}{def} \PY{n+nf}{compare\PYZus{}all}\PY{p}{(}\PY{p}{)}\PY{p}{:}
              \PY{n}{array\PYZus{}1} \PY{o}{=} \PY{p}{[}\PY{p}{]}    
              \PY{n}{rand\PYZus{}size} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{250}\PY{p}{,} \PY{l+m+mi}{500}\PY{p}{,} \PY{l+m+mi}{750}\PY{p}{,} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{5000}\PY{p}{,} \PY{l+m+mi}{7500}\PY{p}{,} \PY{l+m+mi}{10000}\PY{p}{]}
              \PY{n}{functions} \PY{o}{=} \PY{p}{[}\PY{n}{bubbleSort}\PY{p}{,} \PY{n}{insertion\PYZus{}sort}\PY{p}{,} \PY{n}{insertionSort}\PY{p}{,} \PY{n}{mergeSort}\PY{p}{,} \PY{n}{bucketSort}\PY{p}{,} \PY{n+nb}{sorted}\PY{p}{]}
              
              \PY{k}{for} \PY{n}{func} \PY{o+ow}{in} \PY{n}{functions}\PY{p}{:} \PY{c+c1}{\PYZsh{}For every function}
                  \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{rand\PYZus{}size}\PY{p}{:} \PY{c+c1}{\PYZsh{}For every input size i}
                          \PY{n}{size} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{c+c1}{\PYZsh{}generate a random array of i values}
                          \PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
                          \PY{n}{func}\PY{p}{(}\PY{n}{size}\PY{p}{)} \PY{c+c1}{\PYZsh{}pass the array to the function}
                          \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
                          \PY{n}{clock} \PY{o}{=} \PY{n+nb}{round}\PY{p}{(}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{c+c1}{\PYZsh{}calculate running time in milliseconds}
                          \PY{n}{array\PYZus{}1}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{clock}\PY{p}{)} \PY{c+c1}{\PYZsh{}Add running time value to array\PYZus{}1}
          
              \PY{n}{df} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{rand\PYZus{}size}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BubbleSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} 
                                 \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} 
                                 \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} 
                                 \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{array\PYZus{}1}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{60}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
              
              \PY{n}{df}\PY{o}{.}\PY{n}{to\PYZus{}csv}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{data/run\PYZus{}once.csv}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}125}]:} \PY{c+c1}{\PYZsh{}Input an array with 100 values}
          \PY{c+c1}{\PYZsh{}Returns the mean of every 10 values, as an array}
          \PY{k}{def} \PY{n+nf}{mean\PYZus{}array}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{)}\PY{p}{:}
              \PY{n}{average\PYZus{}time} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{y1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y3} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y4} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y5} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y6} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{60}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y7} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{60}\PY{p}{,} \PY{l+m+mi}{70}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y8} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{70}\PY{p}{,} \PY{l+m+mi}{80}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y9} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{80}\PY{p}{,} \PY{l+m+mi}{90}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              \PY{n}{y10} \PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n+nb}{slice}\PY{p}{(}\PY{l+m+mi}{90}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
              
              \PY{n}{results} \PY{o}{=} \PY{p}{[}\PY{n}{y1}\PY{p}{,} \PY{n}{y2}\PY{p}{,} \PY{n}{y3}\PY{p}{,} \PY{n}{y4}\PY{p}{,} \PY{n}{y5}\PY{p}{,} \PY{n}{y6}\PY{p}{,} \PY{n}{y7}\PY{p}{,} \PY{n}{y8}\PY{p}{,} \PY{n}{y9}\PY{p}{,} \PY{n}{y10}\PY{p}{]}
              \PY{k}{return} \PY{n}{results}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}126}]:} \PY{c+c1}{\PYZsh{}Inputs each random array to each function ten times}
          \PY{c+c1}{\PYZsh{}Returns average running time in milliseconds}
          \PY{k}{def} \PY{n+nf}{bench\PYZus{}ten\PYZus{}runs}\PY{p}{(}\PY{p}{)}\PY{p}{:}
              \PY{n}{results}\PY{o}{=}\PY{p}{[}\PY{p}{]}
              \PY{n}{average\PYZus{}time} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{final\PYZus{}array}\PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{num\PYZus{}runs} \PY{o}{=} \PY{l+m+mi}{10}
              \PY{n}{rand\PYZus{}size} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{250}\PY{p}{,} \PY{l+m+mi}{500}\PY{p}{,} \PY{l+m+mi}{750}\PY{p}{,} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{5000}\PY{p}{,} \PY{l+m+mi}{7500}\PY{p}{,} \PY{l+m+mi}{10000}\PY{p}{]}
              \PY{n}{functions} \PY{o}{=} \PY{p}{[}\PY{n}{bubbleSort}\PY{p}{,} \PY{n}{insertion\PYZus{}sort}\PY{p}{,} \PY{n}{insertionSort}\PY{p}{,} \PY{n}{mergeSort}\PY{p}{,} \PY{n}{bucketSort}\PY{p}{,} \PY{n+nb}{sorted}\PY{p}{]}
              
            
              \PY{k}{for} \PY{n}{func} \PY{o+ow}{in} \PY{n}{functions}\PY{p}{:} \PY{c+c1}{\PYZsh{}For each function}
                  \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{rand\PYZus{}size}\PY{p}{:} \PY{c+c1}{\PYZsh{}input a value}
                      \PY{n}{size} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{n}{i}\PY{p}{)} 
                      \PY{k}{for} \PY{n}{r} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{num\PYZus{}runs}\PY{p}{)}\PY{p}{:}\PY{c+c1}{\PYZsh{}ten times}
                          \PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
                          \PY{n}{func}\PY{p}{(}\PY{n}{size}\PY{p}{)} 
                          \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
                          \PY{n}{clock} \PY{o}{=} \PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*}\PY{l+m+mi}{1000}
                          \PY{n}{results}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{clock}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Add time elapsed to array results}
                  \PY{n}{average\PYZus{}time} \PY{o}{=} \PY{n}{mean\PYZus{}array}\PY{p}{(}\PY{n}{results}\PY{p}{)} \PY{c+c1}{\PYZsh{} Find average time, for each i in rand\PYZus{}size, using mean\PYZus{}array()}
                  \PY{n}{average\PYZus{}time} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{n}{average\PYZus{}time}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{c+c1}{\PYZsh{} Round result to 3 dps}
                  \PY{n}{final\PYZus{}array}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{average\PYZus{}time}\PY{p}{)} \PY{c+c1}{\PYZsh{} Append to final\PYZus{}array}
                  \PY{n}{average\PYZus{}time} \PY{o}{=} \PY{p}{[}\PY{p}{]} \PY{c+c1}{\PYZsh{}set both average\PYZus{}time}
                  \PY{n}{results}\PY{o}{=}\PY{p}{[}\PY{p}{]}  \PY{c+c1}{\PYZsh{}and results to [], before passing through the next function}
                  
              \PY{n}{df4} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{rand\PYZus{}size}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BubbleSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} 
                                 \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} 
                                       \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{n}{final\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
              
              \PY{n}{df4}\PY{o}{.}\PY{n}{to\PYZus{}csv}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{data/avg\PYZus{}ten\PYZus{}runs.csv}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}
\end{Verbatim}


    \subsection{Discussion of Sorting
Algorithms}\label{discussion-of-sorting-algorithms}

    \subsubsection{Bubble Sort}\label{bubble-sort}

    Bubble Sort is a simple comparison based sorting algorithm. It compares
every number to it's adjacent number(s), and returns the larger number
of the two, in the position with the larger index. It continues this
process multiple times, looping through the array, until the set is
fully sorted. Let's look at an example.

    

    In the example above, it could be argued that the list of five numbers
was already partially sorted before the algorithm was run. The largest
value 8 has the largest index. In the first pass, my algorithm compares
four pairs of numbers, or \((n-1)\) values, swapping where necessary. As
a result, the second largest number ends up in the second last position.

In this case, it takes 3 passes to sort the input. However in the worse
case scenario, it would take \((n-1)\) passes.

So in the worst case scenario, my algorithm would compare \((n-1)\)
pairs of numbers, \((n-1)\) times.

This means that the number of operations the algorithm performs would be
approximated by \((n-1)(n-1)\), giving us a \(O(n^2)\) time complexity.
I expect that in small sets BubbleSort will work very well, but with
larger input sizes it will take considerably longer to run.

BubbleSort can be modified to stop early if it finds that the list has
become sorted, and in that case it could have a running time of
\(O(n)\). However that is the best case scenario, where the input is
almost sorted list.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{k}{def} \PY{n+nf}{bubbleSort}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{p}{:}
             \PY{k}{for} \PY{n}{passnum} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:} 
                 \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{passnum}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{}Goes through a list from last value to first}
                     \PY{k}{if} \PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{\PYZgt{}}\PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{:} \PY{c+c1}{\PYZsh{} Compares every value to value on its left}
                         \PY{n}{temp} \PY{o}{=} \PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]}  
                         \PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]} 
                         \PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{n}{temp} \PY{c+c1}{\PYZsh{}Swaps two values, if needed, so the larger value has the larger index                }
         \PY{c+c1}{\PYZsh{} Reference: interactivepython.org/runestone/static/pythonds/SortSearch/TheBubbleSort.html, accessed 13th April 2019.}
\end{Verbatim}


    Bubble sort is a stable sort with a space complexity of \(O(1)\).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}51}]:} [14, 42, 4, 55, 28, 51, 56, 61, 94, 43]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{n}{bubbleSort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}53}]:} [4, 14, 28, 42, 43, 51, 55, 56, 61, 94]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{bubbleSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10 random variables}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}54}]:} 1.005
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{bubbleSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10,000}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}55}]:} 63511.847
\end{Verbatim}
            
    \subsubsection{Insertion Sort vs. Binary Insertion
Sort}\label{insertion-sort-vs.-binary-insertion-sort}

    Insertion Sort takes an unsorted list and compares every element to
every element preceding it. In my example below, the first comparison
occurs when I compare the second element, 7, with the first element 9. 7
is less than 9, so we swap them. Then we are comparing the element at
index 3 to all the preceeding elements. 6 is less than both 9 and 7 so
it is moved to index 1.

    

    In this way, Insertion Sort maintains a sorted list to the left of the
element it's currently comparing, and an unsorted list to the right. In
the worse case, if an input was in reverse order, it would have to
compare each element with every preceding number in the sorted list.

My example above, is not the worst case. There are some instances where
the algorithm terminates early, finding the correct index for a number
without having to check every single element of it's already sorted
list.

    This sorting algorithm makes \((1 + 2 + 3 + 4 + 5 + 6 + ... + n-1)\)
comparisons, and in the worst case, it will also complete \((n-1)\)
swaps. This implies that the function will have \(O(n^2)\) time
complexity, similar to BubbleSort. This is also implied by the structure
of the algorithm, which contains two nested loops below.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{k}{def} \PY{n+nf}{insertion\PYZus{}sort}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{p}{:}
             \PY{k}{for} \PY{n}{index} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n+nb}{len}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{}for every element in alist}
                 \PY{n}{currentvalue} \PY{o}{=} \PY{n}{alist}\PY{p}{[}\PY{n}{index}\PY{p}{]} 
                 \PY{n}{position} \PY{o}{=} \PY{n}{index} 
         
                 \PY{k}{while} \PY{n}{position}\PY{o}{\PYZgt{}}\PY{l+m+mi}{0} \PY{o+ow}{and} \PY{n}{alist}\PY{p}{[}\PY{n}{position}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZgt{}}\PY{n}{currentvalue}\PY{p}{:} \PY{c+c1}{\PYZsh{}Until we reach the first value, if the preceding value is bigger }
                     \PY{n}{alist}\PY{p}{[}\PY{n}{position}\PY{p}{]}\PY{o}{=}\PY{n}{alist}\PY{p}{[}\PY{n}{position}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} 
                     \PY{n}{position} \PY{o}{=} \PY{n}{position}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} 
         
                     \PY{n}{alist}\PY{p}{[}\PY{n}{position}\PY{p}{]}\PY{o}{=}\PY{n}{currentvalue} \PY{c+c1}{\PYZsh{}then swap the values and their indexes}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}57}]:} [40, 44, 94, 68, 1, 56, 44, 79, 66, 55]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{n}{insertion\PYZus{}sort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}59}]:} [1, 40, 44, 44, 55, 56, 66, 68, 79, 94]
\end{Verbatim}
            
    This algorithm is as inefficient as BubbleSort, and iterates through the
set linearly comparing each value to other values in the set.

A variation of insertion sort is Binary Insertion Sort. This combines
the insertion sort process with a binary search algorithm, and results
in fewer comparisons having to be made. Binary Search acts upon already
sorted sets. As a result, it is uniquely suited to the Insertion Sort
process, where the elements to the left of the item been sorted, are
already sorted in order from smallest to biggest.

In this way, the binary search algorithm can find the correct positon
for a new element, without comparing it to all previous elements. Even
without calculating the Big O Notation, it is obvious that this should
be a more efficient sorting method.

    Binary insetion sort with duplicate elements - can be sorted to left or
right of the duplicate.

stable, in place and works well on small sets and on sets that are
almost fully sorted

very inefficient for large random sets

iterative

In normal insertion sort, it takes O(n) comparisons(at nth iteration) in
worst case. We can reduce it to O(log n) by using binary search.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{c+c1}{\PYZsh{}Takes a new item, and return the appropriate index for item in sorted array}
         
         \PY{k}{def} \PY{n+nf}{binary\PYZus{}search}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{,} \PY{n}{item}\PY{p}{,} \PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{}Input is a sorted array, item to be place in array, start and end}
             
             \PY{k}{if} \PY{n}{start} \PY{o}{==} \PY{n}{end}\PY{p}{:} \PY{c+c1}{\PYZsh{} if there\PYZsq{}s only one item in the sorted array}
                 \PY{k}{if} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{start}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{n}{item}\PY{p}{:} \PY{c+c1}{\PYZsh{} and start item is bigger than the new item}
                     \PY{k}{return} \PY{n}{start} \PY{c+c1}{\PYZsh{}return start (so the smaller number has index 0)}
                 \PY{k}{else}\PY{p}{:}
                     \PY{k}{return} \PY{n}{start} \PY{o}{+} \PY{l+m+mi}{1} \PY{c+c1}{\PYZsh{}otherwise return start+1 (so the bigger number has index 1)}
                 
             \PY{k}{if} \PY{n}{start} \PY{o}{\PYZgt{}} \PY{n}{end}\PY{p}{:} \PY{c+c1}{\PYZsh{}at the last element of the array}
                 \PY{k}{return} \PY{n}{start} \PY{c+c1}{\PYZsh{}return the index of the last element}
         
             \PY{n}{mid} \PY{o}{=} \PY{n+nb}{round}\PY{p}{(}\PY{p}{(}\PY{n}{start} \PY{o}{+} \PY{n}{end}\PY{p}{)}\PY{o}{/} \PY{l+m+mi}{2}\PY{p}{)} \PY{c+c1}{\PYZsh{}Returns the mean of the range of indices }
             
             \PY{c+c1}{\PYZsh{} determine which side to search}
             \PY{k}{if} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{mid}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n}{item}\PY{p}{:} \PY{c+c1}{\PYZsh{} if new item is less than the middle value}
                 \PY{k}{return} \PY{n}{binary\PYZus{}search}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{,} \PY{n}{item}\PY{p}{,} \PY{n}{mid} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{end}\PY{p}{)} \PY{c+c1}{\PYZsh{} search array of indices above mid}
         
             \PY{k}{elif} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{mid}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{n}{item}\PY{p}{:}
                 \PY{k}{return} \PY{n}{binary\PYZus{}search}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{,} \PY{n}{item}\PY{p}{,} \PY{n}{start}\PY{p}{,} \PY{n}{mid} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} search array of indices below mid}
         
             \PY{k}{else}\PY{p}{:}
                 \PY{k}{return} \PY{n}{mid} \PY{c+c1}{\PYZsh{} Otherwise mid = item, so return mid}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{k}{def} \PY{n+nf}{insertionSort}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{)}\PY{p}{:}
                 
             \PY{n}{l} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{)} \PY{c+c1}{\PYZsh{}set l to the number of values in array}
             \PY{k}{for} \PY{n}{index} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{l}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{}for every index}
                 \PY{n}{value} \PY{o}{=} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{index}\PY{p}{]} \PY{c+c1}{\PYZsh{}value is equal to element in that position}
                 \PY{n}{pos} \PY{o}{=} \PY{n}{binary\PYZus{}search}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{,} \PY{n}{value}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{index} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{}perform binary search to find the appropriate index for value}
                 \PY{n}{the\PYZus{}array} \PY{o}{=} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{p}{:}\PY{n}{pos}\PY{p}{]} \PY{o}{+} \PY{p}{[}\PY{n}{value}\PY{p}{]} \PY{o}{+} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{pos}\PY{p}{:}\PY{n}{index}\PY{p}{]} \PY{o}{+} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{index}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}
             \PY{k}{return} \PY{n}{the\PYZus{}array}
         
         \PY{c+c1}{\PYZsh{}Reference:http://interactivepython.org/courselib/static/pythonds/SortSearch/TheInsertionSort.html, accessed 13th April 2019.}
         \PY{c+c1}{\PYZsh{}Reference:http://skerritt.tech/blog/timsort/, accessed 13th April 2019.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}62}]:} [6, 68, 93, 64, 28, 96, 11, 84, 62, 23]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n}{insertionSort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}63}]:} [6, 11, 23, 28, 62, 64, 68, 84, 93, 96]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{o}{\PYZpc{}}\PY{k}{timeit}(insertionSort)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
181 ns ± 77.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{insertionSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10 random variables}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}65}]:} 0.0
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{insertionSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10,000 random variables}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}66}]:} 7153.777
\end{Verbatim}
            
    \subsubsection{Merge Sort}\label{merge-sort}

    

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}96}]:} \PY{k}{def} \PY{n+nf}{mergeSort}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{p}{:}
         
             \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{o}{\PYZgt{}}\PY{l+m+mi}{1}\PY{p}{:}
                 \PY{n}{mid} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{o}{/}\PY{o}{/}\PY{l+m+mi}{2} \PY{c+c1}{\PYZsh{}get value of middle index}
                 \PY{n}{lefthalf} \PY{o}{=} \PY{n}{alist}\PY{p}{[}\PY{p}{:}\PY{n}{mid}\PY{p}{]} \PY{c+c1}{\PYZsh{}lower subarray is below mid}
                 \PY{n}{righthalf} \PY{o}{=} \PY{n}{alist}\PY{p}{[}\PY{n}{mid}\PY{p}{:}\PY{p}{]} \PY{c+c1}{\PYZsh{}upper subarray is above mid}
         
                 \PY{n}{mergeSort}\PY{p}{(}\PY{n}{lefthalf}\PY{p}{)} 
                 \PY{n}{mergeSort}\PY{p}{(}\PY{n}{righthalf}\PY{p}{)} \PY{c+c1}{\PYZsh{}Pass both subarrays back into merge sort}
         
                 \PY{n}{i}\PY{o}{=}\PY{l+m+mi}{0}
                 \PY{n}{j}\PY{o}{=}\PY{l+m+mi}{0}
                 \PY{n}{k}\PY{o}{=}\PY{l+m+mi}{0}
                 \PY{k}{while} \PY{n}{i} \PY{o}{\PYZlt{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{lefthalf}\PY{p}{)} \PY{o+ow}{and} \PY{n}{j} \PY{o}{\PYZlt{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{righthalf}\PY{p}{)}\PY{p}{:}
                     \PY{k}{if} \PY{n}{lefthalf}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n}{righthalf}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{:}
                         \PY{n}{alist}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{=}\PY{n}{lefthalf}\PY{p}{[}\PY{n}{i}\PY{p}{]}
                         \PY{n}{i}\PY{o}{=}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1} 
                     \PY{k}{else}\PY{p}{:}
                         \PY{n}{alist}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{=}\PY{n}{righthalf}\PY{p}{[}\PY{n}{j}\PY{p}{]}
                         \PY{n}{j}\PY{o}{=}\PY{n}{j}\PY{o}{+}\PY{l+m+mi}{1}
                     \PY{n}{k}\PY{o}{=}\PY{n}{k}\PY{o}{+}\PY{l+m+mi}{1}
         
                 \PY{k}{while} \PY{n}{i} \PY{o}{\PYZlt{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{lefthalf}\PY{p}{)}\PY{p}{:}
                     \PY{n}{alist}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{=}\PY{n}{lefthalf}\PY{p}{[}\PY{n}{i}\PY{p}{]}
                     \PY{n}{i}\PY{o}{=}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}
                     \PY{n}{k}\PY{o}{=}\PY{n}{k}\PY{o}{+}\PY{l+m+mi}{1}
         
                 \PY{k}{while} \PY{n}{j} \PY{o}{\PYZlt{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{righthalf}\PY{p}{)}\PY{p}{:}
                     \PY{n}{alist}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{=}\PY{n}{righthalf}\PY{p}{[}\PY{n}{j}\PY{p}{]}
                     \PY{n}{j}\PY{o}{=}\PY{n}{j}\PY{o}{+}\PY{l+m+mi}{1}
                     \PY{n}{k}\PY{o}{=}\PY{n}{k}\PY{o}{+}\PY{l+m+mi}{1}
                 
                     
         \PY{c+c1}{\PYZsh{}Reference: http://interactivepython.org/courselib/static/pythonds/SortSearch/TheMergeSort.html, accessed 13th April 2019.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}97}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}97}]:} [21, 77, 35, 17, 20, 21, 16, 66, 12, 98]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}98}]:} \PY{n}{mergeSort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}99}]:} \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}99}]:} [12, 16, 17, 20, 21, 21, 35, 66, 77, 98]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{o}{\PYZpc{}}\PY{k}{timeit}(mergeSort)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
218 ns ± 81.8 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{mergeSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10 random variables}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}72}]:} 0.0
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{mergeSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{}10,000 random variables}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}73}]:} 520.126
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{mergeSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{100000}\PY{p}{)}\PY{p}{)}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}74}]:} 6899.121
\end{Verbatim}
            
    \subsubsection{Bucket Sort}\label{bucket-sort}

    Bucket sort is a divide and conquer sorting algorithm. It divides a list
into a number of buckets. Each bucket is sorted individually. This can
be done by applying a different sorting algorithm, or by recursively
applying the bucket sorting algorithm.

    Given a list of numbers, \(29\), \(25\), \(3\), \(49\), \(9\), \(37\),
\(21\), \(43\)

    

    Bucket sort is a stable sort which works by distributing the elements of
an array into a series of buckets. Each bucket is then sorted
individually, wither using a different sorting algorithm or by
recursively applying the Buketsort algorithm.

Time coplexity is n\^{}2 in the worst case, and n+k in the besta and
average, where k is the number of buckets. Worst case space complexity
is O(nk)

buckets sorts performance degrades with clustering if many values occur
close tgether they wil fall in to a single buckets and be sorted slowly

    \textbf{WIKI says}

A bucket sort works best when the elements of the data set are evenly
distributed across all buckets.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{k}{def} \PY{n+nf}{bucketSort}\PY{p}{(}\PY{n}{alist}\PY{p}{)}\PY{p}{:}
             \PY{n}{largest} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{alist}\PY{p}{)} \PY{c+c1}{\PYZsh{}Set max}
             \PY{n}{length} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{alist}\PY{p}{)} \PY{c+c1}{\PYZsh{}Set input size = length}
             \PY{n}{size} \PY{o}{=} \PY{n}{largest}\PY{o}{/}\PY{n}{length} \PY{c+c1}{\PYZsh{}Divide max by len to get range of buckets}
          
             \PY{n}{buckets} \PY{o}{=} \PY{p}{[}\PY{p}{[}\PY{p}{]} \PY{k}{for} \PY{n}{\PYZus{}} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{length}\PY{p}{)}\PY{p}{]}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{length}\PY{p}{)}\PY{p}{:}
                 \PY{n}{j} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{/}\PY{n}{size}\PY{p}{)}
                 \PY{k}{if} \PY{n}{j} \PY{o}{!=} \PY{n}{length}\PY{p}{:}
                     \PY{n}{buckets}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
                 \PY{k}{else}\PY{p}{:}
                     \PY{n}{buckets}\PY{p}{[}\PY{n}{length} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{alist}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
          
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{length}\PY{p}{)}\PY{p}{:}
                 \PY{n}{insertionSort}\PY{p}{(}\PY{n}{buckets}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)} \PY{c+c1}{\PYZsh{} apply insertion sort}
          
             \PY{n}{result} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{length}\PY{p}{)}\PY{p}{:}
                 \PY{n}{result} \PY{o}{=} \PY{n}{result} \PY{o}{+} \PY{n}{buckets}\PY{p}{[}\PY{n}{i}\PY{p}{]}
             \PY{k}{return} \PY{n}{result}
         
         \PY{c+c1}{\PYZsh{}Reference: https://www.sanfoundry.com/python\PYZhy{}program\PYZhy{}implement\PYZhy{}bucket\PYZhy{}sort/, accessed 13th April 2019.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}76}]:} [97, 86, 81, 13, 21, 16, 45, 0, 93, 27]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}77}]:} \PY{n}{bucketSort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}77}]:} [0, 13, 16, 21, 27, 45, 86, 81, 97, 93]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} \PY{o}{\PYZpc{}}\PY{k}{timeit}(bucketSort)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
168 ns ± 22 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} \PY{n}{start} \PY{o}{=}\PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{bucketSort}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
         \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{p}{(}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}\PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}79}]:} 1.004
\end{Verbatim}
            
    \subsubsection{TimSort}\label{timsort}

    Timsort is a hybrid stable sorting algorithm, using elements of both
merge sort and insertion sort. It is designed to find short lists within
the input that are already ordered.

While I will be able to apply the binary search and insertion sorts
algorithms already discussed in this project. I will use a variation of
merge sort, different from the function previously encountered. Merge()
is a function that takes two already sorted lists of numbers and puts
them in order. This is different from mergeSort, which takes an
unordered set and divides it into smaller subsets before merging. With
TimSort, the subsets or runs, have already been ordered using Insertion
Sort.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}81}]:} \PY{k}{def} \PY{n+nf}{merge}\PY{p}{(}\PY{n}{left}\PY{p}{,} \PY{n}{right}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{}Input is two sorted lists}
             \PY{k}{if} \PY{o+ow}{not} \PY{n}{left}\PY{p}{:}
                 \PY{k}{return} \PY{n}{right}
             \PY{k}{if} \PY{o+ow}{not} \PY{n}{right}\PY{p}{:}
                 \PY{k}{return} \PY{n}{left}
             \PY{k}{if} \PY{n}{left}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n}{right}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{:}
                 \PY{k}{return} \PY{p}{[}\PY{n}{left}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]} \PY{o}{+} \PY{n}{merge}\PY{p}{(}\PY{n}{left}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{,} \PY{n}{right}\PY{p}{)}
             \PY{k}{return} \PY{p}{[}\PY{n}{right}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]} \PY{o}{+} \PY{n}{merge}\PY{p}{(}\PY{n}{left}\PY{p}{,} \PY{n}{right}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}Reference:http://skerritt.tech/blog/timsort/, accessed 13th April 2019.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{k}{def} \PY{n+nf}{timSort}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{)}\PY{p}{:}
          
             \PY{n}{runs}\PY{p}{,} \PY{n}{sorted\PYZus{}runs} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{p}{]}
             \PY{n}{length} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{)}
             \PY{n}{new\PYZus{}run} \PY{o}{=} \PY{p}{[}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}
         
             \PY{c+c1}{\PYZsh{} for every i in the range of 1 to length of array}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{length}\PY{p}{)}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} if i is at the end of the list}
                 \PY{k}{if} \PY{n}{i} \PY{o}{==} \PY{n}{length} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{:}
                     \PY{n}{new\PYZus{}run}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
                     \PY{n}{runs}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{new\PYZus{}run}\PY{p}{)}
                     \PY{k}{break}
                 \PY{c+c1}{\PYZsh{} if the i\PYZsq{}th element of the array is less than the one before it}
                 \PY{k}{if} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{:}
                     \PY{c+c1}{\PYZsh{} if new\PYZus{}run is set to None (NULL)}
                     \PY{k}{if} \PY{o+ow}{not} \PY{n}{new\PYZus{}run}\PY{p}{:}
                         \PY{n}{runs}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{[}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{]}\PY{p}{)}
                         \PY{n}{new\PYZus{}run}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
                     \PY{k}{else}\PY{p}{:}
                         \PY{n}{runs}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{new\PYZus{}run}\PY{p}{)}
                         \PY{n}{new\PYZus{}run} \PY{o}{=} \PY{p}{[}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{]}
                 \PY{c+c1}{\PYZsh{} else if its equal to or more than}
                 \PY{k}{else}\PY{p}{:}
                     \PY{n}{new\PYZus{}run}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{the\PYZus{}array}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} for every item in runs, append it using binary insertion sort}
             \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{runs}\PY{p}{:}
                 \PY{n}{sorted\PYZus{}runs}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{insertionSort}\PY{p}{(}\PY{n}{item}\PY{p}{)}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} for every run in sorted\PYZus{}runs, merge them}
             \PY{n}{sorted\PYZus{}array} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             \PY{k}{for} \PY{n}{run} \PY{o+ow}{in} \PY{n}{sorted\PYZus{}runs}\PY{p}{:}
                 \PY{n}{sorted\PYZus{}array} \PY{o}{=} \PY{n}{merge}\PY{p}{(}\PY{n}{sorted\PYZus{}array}\PY{p}{,} \PY{n}{run}\PY{p}{)}
             
             \PY{k}{return} \PY{n}{sorted\PYZus{}array}
             
         \PY{c+c1}{\PYZsh{}Reference:http://skerritt.tech/blog/timsort/, accessed 13th April 2019.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} \PY{n}{mylist} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}83}]:} [69, 50, 75, 66, 58, 87, 52, 60, 24, 3]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}84}]:} \PY{n}{timSort}\PY{p}{(}\PY{n}{mylist}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}84}]:} [3, 24, 50, 52, 58, 60, 66, 69, 75, 87]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}85}]:} \PY{n}{mylist}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}85}]:} [69, 50, 75, 66, 58, 87, 52, 60, 24, 3]
\end{Verbatim}
            
    While testing this sorting algorithm, the code I found online often
returned duplicates or incomplete lists of sorted items. I was able to
correct the code, to get it to return a correctly sorted list, but this
led to a recursion error when inputting large lists, with maximum
recursion depth exceeded in comparison.

The recursion error arose when passing large input sizes through the
merge function using TimSort. I tried adapting my merge function to
solve this problem. Using mergeSort function, and inbuilt functions like
heapq.merge, the function ran without a recursion error. However neither
of those functions were designed to run on already sorted sets, and took
much longer than expected. They made TimSort ineffective, taking longer
than BucketSort and MergeSort to execute.

    I will have to do some further investigations to determine why this
function is returning a recursion error for certain input sizes. For the
moment, I will remove TimSort from my benchmarking analysis, as I don't
believe the code accurately reflects its capabilities.

TimSort should be the most effective sorting algorithm I investigated as
part of this project. It should have \(O(nlogn)\) time complexity for
worst case and \(O(n)\) for best case scenarios, but at the moment, my
code doesn't reflect this.

    \subsection{Comparing Sorting
Algorithms}\label{comparing-sorting-algorithms}

    For the purposes of benchmarking my sorting algorithms, I will pass ten
sets of randomly generated data to each once. I will be comparing
BubbleSort, InsertionSort, Binary InsertionSort, MergeSort and
BucketSort.

Instead of using an implementation of TimSort, I will include the Python
in-built function sorted, which uses Tim Peter's algorithm. I realise
that this doesn't fully meet the needs of the project specification, but
I am interested to see how Python's in-built sorting algorithms compare
to the algorithms I have investigated.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}115}]:} \PY{n}{compare\PYZus{}all}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}151}]:} \PY{n}{df} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{read\PYZus{}csv}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data/run\PYZus{}once.csv}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{df}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}151}]:}    Input Size  BubbleSort  InsertionSort  Binary InsertionSort  MergeSort  \textbackslash{}
          0          10       0.000          0.000                 0.000      0.000   
          1          50       1.001          1.001                 1.002      1.002   
          2         100       0.999          1.000                 1.000      1.000   
          3         250      13.007         31.009                 4.001      1.000   
          4         500      84.020         26.008                10.003      3.999   
          5         750     207.054        114.025               126.033      6.002   
          6        1000     317.083        217.053                64.014      9.002   
          7        5000    7679.935       6218.567              1250.319    129.033   
          8        7500   17319.371      12814.232              2817.712    190.048   
          9       10000   31661.993      28189.116              4825.219    356.089   
          
             BucketSort  Sorted  
          0       0.000   0.000  
          1       0.000   0.000  
          2       0.000   0.999  
          3       0.999   0.000  
          4       3.003   0.000  
          5       7.002   0.000  
          6      11.003   1.000  
          7     639.164   1.997  
          8     353.092   2.999  
          9     891.230   4.000  
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}120}]:} \PY{n}{ax} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BubbleSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time Elapsed (milliseconds)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_79_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}121}]:} \PY{n}{ax} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time Elapsed (milliseconds)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_80_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}122}]:} \PY{n}{ax} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time Elapsed (milliseconds)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_81_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Benchmarking Sorting
Algorithms}\label{benchmarking-sorting-algorithms}

    For the purposes of benchmarking my sorting algorithms, I will pass ten
sets of randomly generated data to each function ten times. I will be
use the same six algorithms from the previous comparison: BubbleSort,
InsertionSort, Binary InsertionSort, MergeSort, BucketSort and Python's
in-built Sorted function.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}127}]:} \PY{n}{bench\PYZus{}ten\PYZus{}runs}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}128}]:} \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{read\PYZus{}csv}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data/avg\PYZus{}ten\PYZus{}runs.csv}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}128}]:}    Input Size  BubbleSort  InsertionSort  Binary InsertionSort  MergeSort  \textbackslash{}
          0          10       0.000          0.000                 0.100      0.000   
          1          50       0.400          0.100                 0.300      0.199   
          2         100       1.201          0.200                 1.000      0.500   
          3         250      10.002          0.700                 4.801      2.301   
          4         500      51.213          5.701                15.804      6.001   
          5         750     113.828         12.103                27.707      6.902   
          6        1000     185.047         21.006                43.711     11.303   
          7        5000    5847.776        481.821               728.183     65.316   
          8        7500   13840.193       1136.586              1572.297    109.628   
          9       10000   18117.572       1971.498              2751.694    149.637   
          
             BucketSort  Sorted  
          0       0.000   0.000  
          1       0.200   0.000  
          2       1.501   0.000  
          3       1.201   0.100  
          4       5.302   1.201  
          5       5.602   0.200  
          6      10.503   0.300  
          7     174.544   1.800  
          8     341.186   5.801  
          9     573.645   5.801  
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}132}]:} \PY{n}{ax} \PY{o}{=} \PY{n}{df2}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BubbleSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time Elapsed (milliseconds)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_86_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}133}]:} \PY{n}{ax} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Input Size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binary InsertionSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MergeSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BucketSort}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sorted}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
          \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time Elapsed (milliseconds)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_87_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{References}\label{references}

    \paragraph{Documentation}\label{documentation}

\begin{itemize}
\tightlist
\item
  \href{https://docs.python.org/3/library/}{The Python Standard Library}
  \textgreater{} *
  \href{https://docs.python.org/3/library/time.html}{Time} function,
  accessed 13th April 2019. \textgreater{} *
  \href{https://docs.python.org/3/library/csv.html}{Reading and Writing
  CSV files}, accessed 13th April 2019.
\item
  \href{}{Pandas Documentation} \textgreater{} *
  \href{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html}{pandas.DataFrame}
  function, accessed 13th April 2019. \_\_\_
\end{itemize}

    \paragraph{Wikipedia Pages}\label{wikipedia-pages}

\begin{itemize}
\tightlist
\item
  \href{https://en.wikipedia.org/wiki/In-place_algorithm}{In-Place
  Algorithm}, accessed 25 April 2019.
\item
  \href{https://en.wikipedia.org/wiki/Timsort}{TimSort}, accessed 23
  April 2019.
\end{itemize}

    \paragraph{Other}\label{other}

\begin{itemize}
\tightlist
\item
  \href{https://www.geeksforgeeks.org/binary-insertion-sort/}{Binary
  Insertion Sort}, page on geeksforgeeks.org, accessed 25 April 2019.
\item
  \href{https://dev.to/s_awdesh/timsort-fastest-sorting-algorithm-for-real-world-problems--2jhd}{Timsort:
  The Fastest sorting algorithm for real-world problems}, blog post by
  Awdesh, accessed 5 May 2019..
\end{itemize}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
